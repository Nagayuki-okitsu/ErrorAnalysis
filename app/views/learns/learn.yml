#問題の答えは選択肢の1つ目とする。
#kind=エラーの種類、difc(difficulty)=難易度、q_pro(question program)=問題用のプログラム、q_err(question error)=問題用のエラー、c_a(cause answer)=原因問題の答え、s_a(solve answer)=解決問題の答え、ans(answer)=回答・解説
#(NameError-e:5,n:5,h:4)-()

- kind: NameError

  difc: easy

  q_pro: |
          hello = "Hello World"

          puts helle

  q_err: |
          Main.rb:3:in `<main>': undefined local variable or method `helle' for main:Object (NameError)
          Did you mean?  hello

  c_a: 
    - | 
       3行目で変数helloの名前を間違えている。
    - |
       変数helloに代入されている型が不適切である。
    - |
       putsメソッドの使い方を間違えている。
    - |
       変数の名前は大文字から始めなければならない。

  s_a:
    - |
       3行目を puts hello にする。
    - |
       1行目を hello = Hello World にする。
    - |
       3行目を puts = helle にする。
    - |
       1行目を Hello = "Hello World" にする。

  ans: "このプログラムではNameErrorというエラーが起きています。\
        NameErrorは変数や配列、メソッドの名前を間違えているときに発生します。\n
        （そもそも存在しない または 使用できない範囲に存在する変数や配列、メソッドを使用\
        しようとしたときにも発生することがあります。)\n\n　単純に名前を間違えている\
        場合、エラーメッセージの中に「Did you mean? ○○」という記述があります。\
        これは「あなたが使用したいのは○○ではないですか？」という意味であり、\
        問題のエラーメッセージにも「Did you mean? hello」という記述があります。\
        そのため変数helloの名前を間違えていることが推測できます。\n
        　またエラーメッセージの中に「undefined local variable or method `○○'」という\
        記述もあります。これは「○○という変数または配列、メソッドを知りません」という意味であり、\
        問題のエラーメッセージにも「undefined local variable or method `helle'」という記述があります。\
        そのためプログラムの中に「helle」という使用できない何かが存在することがわかります。\n\n
        　以上をもとに推測すると、「helle」という使用できない何かが原因でエラーが起きており、\
        これは1行目で宣言されている変数helloの名前を間違えたものだという事がわかります。"


- kind: NameError

  difc: easy

  q_pro: |
          hello = "Hello World"

          put hello

  q_err: |
          Main.rb:3:in `<main>': undefined method `put' for main:Object (NoMethodError)
          Did you mean?  puts

  c_a: 
    - | 
       3行目で出力メソッドの名前を間違えている。
    - |
       3行目で変数helloの名前を間違えている。
    - |
       1行目で変数helloの宣言方法を間違えている。
    - |
       3行目の出力メソッドの使い方が不適切である。

  s_a:
    - |
       3行目を puts hello にする。
    - |
       3行目を put helle にする。
    - |
       3行目を put HELLO にする。
    - |
       3行目を puts a にする。

  ans: "このプログラムではNameErrorというエラーが起きています。\
        NameErrorは変数や配列、メソッドの名前を間違えているときに発生します。\n
        （そもそも存在しない または 使用できない範囲に存在する変数や配列、メソッドを使用\
        しようとしたときにも発生することがあります。)\n\n　単純に名前を間違えている\
        場合、エラーメッセージの中に「Did you mean? ○○」という記述があります。\
        これは「あなたが使用したいのは○○ではないですか？」という意味であり、\
        問題のエラーメッセージにも「Did you mean? puts」という記述があります。\
        そのためputsメソッドの名前を間違えていることが推測できます。\n
        　またエラーメッセージの中に「undefined local variable or method `○○'」という\
        記述もあります。これは「○○という変数または配列、メソッドを知りません」という意味であり、\
        問題のエラーメッセージにも「undefined local variable or method `put'」という記述があります。\
        そのためプログラムの中に「put」という使用できない何かが存在することがわかります。\n\n
        　以上をもとに推測すると、「helle」という使用できない何かが原因でエラーが起きており、\
        これは1行目で宣言されている変数helloの名前を間違えたものだという事がわかります。"
        


- kind: NameError

  difc: easy

  q_pro: |
          array = ["ruby","C","Java"]
          
          puts arroy[0]

  q_err: |
          Main.rb:3:in `<main>': undefined local variable or method `arroy' for main:Object (NameError)
          Did you mean?  array

  c_a: 
    - | 
       3行目で配列arrayの名前を間違えている。
    - |
       1行目で配列の宣言方法を間違えている。
    - |
       3行目で配列の要素の取得方法を間違えている。
    - |
       endが不足している。

  s_a:
    - |
       3行目を puts array[0] にする。
    - |
       1行目を arroy = ["※省略"] にする。
    - |
       3行目を puts orray[0] にする。
    - |
       3行目を put array[0] にする。

  ans: "このプログラムではNameErrorというエラーが起きています。\
        NameErrorは変数や配列、メソッドの名前を間違えているときに発生します。\n
        （そもそも存在しない または 使用できない範囲に存在する変数や配列、メソッドを使用\
        しようとしたときにも発生することがあります。)\n\n　単純に名前を間違えている\
        場合、エラーメッセージの中に「Did you mean? ○○」という記述があります。\
        これは「あなたが使用したいのは○○ではないですか？」という意味であり、\
        問題のエラーメッセージにも「Did you mean? array」という記述があります。\
        そのため配列arrayの名前を間違えていることが推測できます。\n
        　またエラーメッセージの中に「undefined local variable or method `○○'」という\
        記述もあります。これは「○○という変数または配列、メソッドを知りません」という意味であり、\
        問題のエラーメッセージにも「undefined local variable or method `arroy'」という記述があります。\
        そのためプログラムの中に「arroy」という使用できない何かが存在することがわかります。\n\n
        　以上をもとに推測すると、「arroy」という使用できない何かが原因でエラーが起きており、\
        これは1行目で宣言されている配列arrayの名前を間違えたものだという事がわかります。"



- kind: NameError

  difc: easy

  q_pro: |
          width = 5
          height = 3
          
          a = wibth + height

          puts a

  q_err: |
          Main.rb:4:in `<main>': undefined local variable or method `wibth' for main:Object (NameError)
          Did you mean?  width

  c_a: 
    - | 
       4行目で変数widthの名前を間違えている。
    - |
       4行目で変数heightの名前を間違えている。
    - |
       putsメソッドの使い方を間違えている。
    - |
       endが不足している。

  s_a:
    - |
       4行目を a = width + height にする。
    - |
       4行目を a = wibth + haight にする。
    - |
       4行目を a = width + haight にする。
    - |
       4行目を b = width + height にする。

  ans: "このプログラムではNameErrorというエラーが起きています。\
        NameErrorは変数や配列、メソッドの名前を間違えているときに発生します。\n
        （そもそも存在しない または 使用できない範囲に存在する変数や配列、メソッドを使用\
        しようとしたときにも発生することがあります。)\n\n　単純に名前を間違えている\
        場合、エラーメッセージの中に「Did you mean? ○○」という記述があります。\
        これは「あなたが使用したいのは○○ではないですか？」という意味であり、\
        問題のエラーメッセージにも「Did you mean? width」という記述があります。\
        そのため変数widthの名前を間違えていることが推測できます。\n
        　またエラーメッセージの中に「undefined local variable or method `○○'」という\
        記述もあります。これは「○○という変数または配列、メソッドを知りません」という意味であり、\
        問題のエラーメッセージにも「undefined local variable or method `wibth'」という記述があります。\
        そのためプログラムの中に「wibth」という使用できない何かが存在することがわかります。\n\n
        　以上をもとに推測すると、「wibth」という使用できない何かが原因でエラーが起きており、\
        これは1行目で宣言されている変数widthの名前を間違えたものだという事がわかります。\n\n
        選択肢の「4行目を b = width + height にする。」は変数の名前は正しいですが、代入する変数をbに\
        してしまっており、6行目の「puts a」でNameErrorとなってしまうため不適切となります。"



- kind: NameError

  difc: easy

  q_pro: |
          x = 1
          y = 2

          puts z

  q_err: |
          Main.rb:4:in `<main>': undefined local variable or method `z' for main:Object (NameError)

  c_a: 
    - | 
       4行目で存在しない変数zを出力しようとしている。
    - |
       4行目でputsメソッドの使い方を間違えている。
    - |
       1,2行目で変数の宣言方法を間違えている。
    - |
       putsメソッドにはendが必要である。
  
  s_a:
    - |
       4行目を puts x もしくは puts y にする、または4行目以前で変数zを宣言する。
    - |
       4行目を puts x もしくは puts y にする、または4行目以降で変数zを宣言する。
    - |
       4行目を puts xy にする。
    - |
       4行目を puts x * z

  ans: "このプログラムではNameErrorというエラーが起きています。\
        NameErrorは変数や配列、メソッドの名前を間違えているときに発生します。\n
        （そもそも存在しない または 使用できない範囲に存在する変数や配列、メソッドを使用\
        しようとしたときにも発生することがあります。)\n\n
        　この問題のプログラムでは存在しない変数である「z」を出力しようとしてNameErrorが発生しています。\
        エラーメッセージを見ると「undefined local variable or method `z'」（zという変数または配列、メソッドを知りません）\
        という記述があり、変数zを宣言していないことがわかります。よってこのエラーを解決するには4行目以前のどこかで変数zを宣言\
        する必要があります。\n\nプログラムは上から順番に処理が行われるため、4行目以降で変数zを宣言すると変数zが存在しない状態で puts z \
        が行われてしまい、NameErrorとなってしまいます。よって選択肢の「（※省略）、または4行目以降で変数zを宣言する。」は不適切となります。"





- kind: NameError

  difc: normal

  q_pro: |
          a = gets.to_i

          x = a + 1

          puts y

  q_err: |
          Main.rb:5:in `<main>': undefined local variable or method `y' for main:Object (NameError)

  c_a: 
    - | 
       5行目で存在しない変数yを出力しようとしている。
    - |
       1行目のgetsメソッドの使い方が不適切である。
    - |
       5行目のputsメソッドの使い方が不適切である。
    - |
       getsメソッドにはendが必要である。

  s_a:
    - |
       5行目を puts x または puts a にする、または5行目以前で変数yを宣言する。
    - |
       5行目を puts x または puts a にする、または5行目以降で変数yを宣言する。
    - |
       5行目を puts xya にする。
    - |
       1行目を y = gets.to_i にする。

  ans: "このプログラムではNameErrorというエラーが起きています。\
        NameErrorは変数や配列、メソッドの名前を間違えているときに発生します。\n
        （そもそも存在しない または 使用できない範囲に存在する変数や配列、メソッドを使用\
        しようとしたときにも発生することがあります。)\n\n
        　この問題のプログラムでは存在しない変数である「y」を出力しようとしてNameErrorが発生しています。\
        エラーメッセージを見ると「undefined local variable or method `y'」（yという変数または配列、メソッドを知りません）\
        という記述があり、変数yを宣言していないことがわかります。よってこのエラーを解決するには5行目以前のどこかで変数yを宣言\
        する必要があります。\n\n　プログラムは上から順番に処理が行われるため、5行目以降で変数yを宣言すると変数yが存在しない状態で puts y \
        が行われてしまい、NameErrorとなってしまいます。よって選択肢の「(※省略)、または5行目以降で変数yを宣言する。」は不適切となります。\
        また選択肢の「1行目を y = gets.to_i にする。」では5行目の「puts y」に対するNameErrorは解決しますが、3行目の「x = a + 1」\
        がNameErrorとなってしまう(変数aが宣言されていない）ため不適切となります。"






- kind: NameError

  difc: normal

  q_pro: |
          fruit = ["リンゴ","みかん","モモ"]

          puts animal[0]

  q_err: |
          Main.rb:3:in `<main>': undefined local variable or method `animal' for main:Object (NameError)

  c_a: 
    - | 
       3行目で存在しない配列animalの要素を出力しようとしている。
    - |
       3行目で配列animalの添え字を間違えている。
    - |
       1行目で配列fruitに代入している型が不適切である。
    - |
       配列の宣言にはendが必要である。

  s_a:
    - |
       3行目を puts fruit[0] にする、または3行目以前で配列animalを宣言する。
    - |
       3行目を puts fruit[0] にする、または3行目以降で配列animalを宣言する。
    - |
       1行目を apple = ["(※省略)"] にする。
    - |
       1行目の処理を3行目以降に行う。

  ans: "このプログラムではNameErrorというエラーが起きています。\
        NameErrorは変数や配列、メソッドの名前を間違えているときに発生します。\n
        （そもそも存在しない または 使用できない範囲に存在する変数や配列、メソッドを使用\
        しようとしたときにも発生することがあります。)\n\n
        　この問題のプログラムでは存在しない配列である「animal」を出力しようとしてNameErrorが発生しています。\
        エラーメッセージを見ると「undefined local variable or method `animal'」（zという変数または配列、メソッドを知りません）\
        という記述があり、配列animalを宣言していないことがわかります。よってこのエラーを解決するには3行目以前のどこかで配列animalを宣言\
        する必要があります。\n\n　プログラムは上から順番に処理が行われるため、3行目以降で配列animalを宣言すると配列animalが存在しない状態で puts animal[0] \
        が行われてしまい、NameErrorとなってしまいます。よって選択肢の「（※省略）、または3行目以降で配列animalを宣言する。」は不適切となります。"



- kind: NameError

  difc: normal

  q_pro: |
          hello = ハロー

          puts hello

  q_err: |
          Main.rb:1:in `<main>': undefined local variable or method ` ハロー' for main:Object (NameError)

  c_a: 
    - | 
       1行目の変数helloへの代入処理が不適切である。
    - |
       3行目で変数helloの名前を間違えている。
    - |
       3行目で存在しない変数helloを出力しようとしている。
    - |
       3行目のputsメソッドの使い方が不適切である。

  s_a:
    - |
       1行目を hello = "ハロー" にする。
    - |
       1行目を hello = [ ハロー ] にする。
    - |
       1行目を hello = #{ハロー} にする。
    - |
       1行目を hello == "ハロー" にする。

  ans: "この問題のプログラムでは文字列の扱いが不適切でエラーが起きています。\
        プログラムに文字列であることを認識させるにはダブルクォーテーションでその文字列を囲む必要があります。\n\n
        　※日本語文字列を変数として利用できるプログラミング言語も多数存在しており、この問題では1行目のハローが変数や配列、\
        メソッドであると認識されNameErrorとなっています。(NameError:名前を間違えている、または宣言されていない変数や配列\
        メソッドを使用しようとした場合に発生するエラー）"




- kind: NameError

  difc: normal

  q_pro: |
          def apple
            puts "りんご"
          end

          applo

  q_err: |
          Main.rb:5:in `<main>': undefined local variable or method `applo' for main:Object (NameError)
          Did you mean?  apple

  c_a: 
    - | 
       5行目でappleメソッドの名前を間違えている。
    - |
       メソッドの定義方法が不適切である。
    - |
       2行目でputsメソッドの使い方を間違えている。
    - |
       endが不足している。

  s_a:
    - |
       5行目を apple にする。
    - |
       1行目を def = apple にする。
    - |
       1行目を def applo にする。
    - |
       1行目を def Apple にする。

  ans: 
        "このプログラムではNameErrorというエラーが起きています。\
        NameErrorは変数や配列、メソッドの名前を間違えているときに発生します。\n
        （そもそも存在しない または 使用できない範囲に存在する変数や配列、メソッドを使用\
        しようとしたときにも発生することがあります。)\n\n　単純に名前を間違えている\
        場合、エラーメッセージの中に「Did you mean? ○○」という記述があります。\
        これは「あなたが使用したいのは○○ではないですか？」という意味であり、\
        問題のエラーメッセージにも「Did you mean? apple」という記述があります。\
        そのためappleメソッドの名前を間違えていることが推測できます。\n
        　またエラーメッセージの中に「undefined local variable or method `○○'」という\
        記述もあります。これは「○○という変数または配列、メソッドを知りません」という意味であり、\
        問題のエラーメッセージにも「undefined local variable or method `applo'」という記述があります。\
        そのためプログラムの中に「applo」という使用できないメソッドが存在することがわかります。\n\n
        　以上をもとに推測すると、「applo」という使用できないメソッドが原因でエラーが起きており、\
        これは1～3行目で定義されているappleメソッドの名前を間違えたものだという事がわかります。"


- kind: NameError

  difc: normal

  q_pro: |
          lion = "ライオン"
          rabbit = "ウサギ"

          animal = [lion , robbit]

          puts animal[1]

  q_err: |
          Main.rb:4:in `<main>': undefined local variable or method `robbit' for main:Object (NameError)
          Did you mean?  rabbit

  c_a: 
    - | 
       4行目で変数rabbitの名前を間違えている。
    - |
       4行目で変数lionの名前を間違えている。
    - |
       6行目で配列animalの名前を間違えている。
    - |
       6行目の配列animalの添え字が不適切である。

  s_a:
    - |
       4行目を animal = [lion , rabbit] にする。
    - |
       4行目を animal = [laion, robbit] にする。
    - |
       4行目を animol = [lion, rabbit] にする。
    - |
       4行目を animal = [lion, rabbot] にする。

  ans: 
        "このプログラムではNameErrorというエラーが起きています。\
        NameErrorは変数や配列、メソッドの名前を間違えているときに発生します。\n
        （そもそも存在しない または 使用できない範囲に存在する変数や配列、メソッドを使用\
        しようとしたときにも発生することがあります。)\n\n　単純に名前を間違えている\
        場合、エラーメッセージの中に「Did you mean? ○○」という記述があります。\
        これは「あなたが使用したいのは○○ではないですか？」という意味であり、\
        問題のエラーメッセージにも「Did you mean? rabbit」という記述があります。\
        そのため変数rabbitの名前を間違えていることが推測できます。\n
        　またエラーメッセージの中に「undefined local variable or method `○○'」という\
        記述もあります。これは「○○という変数または配列、メソッドを知りません」という意味であり、\
        問題のエラーメッセージにも「undefined local variable or method `robbit'」という記述があります。\
        そのためプログラムの中に「robbit」という使用できない配列が存在することがわかります。\n\n
        　以上をもとに推測すると、「robbit」という使用できない配列が原因でエラーが起きており、\
        これは1行目で宣言されている変数rabbitの名前を間違えたものだという事がわかります。\n\n
        選択肢の「4行目を animol = [lion, rabbit] にする。」は変数の名前は正しいですが、代入する配列をanimolに\
        してしまっており、6行目の「puts animal[1]」でNameErrorとなってしまうため不適切となります。"



- kind: NameError

  difc: hard

  q_pro: |
          class Hello

               def initialize
                  @hello = "Hello World"
               end

               def say_hello
                  
                     if flg == true
                        puts @hello
                    end
                        
              end

          end

          flg = true

          hello = Hello.new

          hello.say_hello
          
  q_err: |
          Main.rb:9:in `say_hello': undefined local variable or method `flg' for 
          #<Hello:0x00000000018438d8 @hello="Hello World"> (NameError) from Main.rb:21:in `<main>'

  c_a: 
    - |
       say_helloメソッドが変数flgのスコープ外である。
    - |
       initializeメソッドが呼ばれていないため@helloの作成に失敗している。
    - |
       Helloクラスでインスタンス変数ではない変数flgが使用されている。
    - |
       21行目でsay_helloメソッドの名前を間違えている。

  s_a:
    - |
       say_helloメソッド内かつif文以前で変数flgを宣言する。
    - |
       Helloクラス内のどこかで変数flgを宣言する。
    - |
       Helloクラスの定義前に変数flgを宣言する。
    - |
       initializeメソッドで変数flgを宣言する。

  ans: 
       "ある変数を使用できる範囲の事をスコープと呼びます。またこの範囲のことをブロックと呼び、これはif文の中、\
       メソッドの中、クラスの中など色々あります。\n\n
       　if flg == true    def say_hello    class Hello\n
       　  （省略）           （省略）           （省略）         ・・・ ブロック\n
       　end                 end                 end\n\n
       　あるブロックで宣言された変数がその他の全てのブロックで使用できるわけではありません。例えば普通はif文のブロック内で宣言\
       された変数はif文のブロック内のみがスコープとなりif文の外側では使用することができません。（※Rubyでは使用できます。）しかしif文のブロックの外側で宣言された変数は\
       if文のブロック内で使用することができます。これはその変数のスコープ内にif文のブロックが入っているためです。メソッドもif文と同じようにブロックの内側で宣言された変数を外側で使用することはできません。\
       しかしメソッドはif文とは異なり、ブロックの外側で宣言された変数を内側で使用することもできません。\
       つまりメソッドのブロックは外側とは繋がっていないようなイメージです。その代わりにメソッドは引数や戻り値によってブロックの外側とやり取りをします。\
       このように各ブロックによって変数のスコープは異なります。\n\n
       　問題のプログラムを見てみるとsay_helloメソッドのブロック内で使用されている変数flgはそのブロックの外側で宣言されていることが\
       わかります。say_helloメソッドは引数を取っているわけでもないため外側で宣言されている変数flgを使用することができません。\
       よってこのエラーを解決するには変数flgをsay_helloメソッドのブロック内かつif文ブロック以前で宣言する必要があります。\n\n
       　(その他にも変数flgを引数としてsay_helloメソッドに渡したり、Helloクラス内のメソッドで@flgを宣言したり、Helloクラス内のどこかで@@flgを宣言したりする方法があります。\
       （インスタンス変数やクラス変数はブロックに関係なくそのクラス内の全てがスコープとなります）)\n\n
       　また原因の選択肢の「initializeメソッドが呼ばれていないため@helloの作成に失敗している。」について、initializeメソッドはクラス名.new\
       で呼ばれるメソッドであり、19行目で呼ばれているため不正解。「Helloクラスでインスタンス変数ではない変数flgが使用されている。」について、\
       クラスの中ではインスタンス変数だけでなく普通の変数やクラス変数なども使用できるため不正解となります。"



- kind: NameError

  difc: hard

  q_pro: |
          def add_ten
    
               return a + 10
            
          end

          a = 5

          puts add_ten
          
  q_err: |
          Main.rb:3:in `add_ten': undefined local variable or method `a' for main:Object (NameError)
          from Main.rb:9:in `<main>'

  c_a: 
    - |
       変数aがスコープ外で使用されている。
    - |
       add_tenメソッドの戻り値が不適切である。
    - |
       add_tenメソッドで使用されている変数の名前を間違えている。
    - |
       変数aがadd_tenメソッドの下で宣言されている。

  s_a:
    - |
       add_tenメソッドに引数として変数aを渡す。
    - |
       add_tenメソッドの上で変数aを宣言する。
    - |
       add_tenメソッドの戻り値を変数bにする。
    - |
       add_tenメソッドの名前をadd_aにする。

  ans: 
       "ある変数を使用できる範囲の事をスコープと呼びます。またこの範囲のことをブロックと呼び、これはif文の中、\
       メソッドの中、クラスの中など色々あります。\n\n
       　if ○○            def ○○           class ○○\n
       　 （省略）            (省略)              (省略)    ・・・ブロック\n
       　end               end                 end\n\n
       　メソッドのブロックは外側と直接つながっていません。つまり選択肢の「add_tenメソッドの上で変数aを宣言する。」\
       としても宣言された変数aをadd_tenメソッドのブロック内で使用することはできません。これは変数aのスコープに\
       add_tenメソッドが含まれていないと言い換えることもできます。ではどうすれば変数aのスコープにadd_tenメソッドを\
       入れることができるのでしょうか。この問題を解決するには「引数」というものを使用します。メソッドは外側のブロックと\
       直接つながっていませんが、引数を使用すると外側の変数や配列などを参照することができます。\n\n
       　① 【メソッド定義】def add_ten(a)  ・・・ メソッド名（仮引数）\n\n
       　→ メソッドが引数を受け取ることができるようになります。\n\n
       　② 【メソッドの外側】add_ten(a) ・・・ メソッド名（実引数）\n\n
       　→ メソッドに引数を渡すことができます。\n\n
       　このようにして変数をメソッドに渡せば、その変数はメソッドのブロック内で使用できるようになります。\n\n\n\n
       　【デバッグ後の問題プログラム】\n\n
       　def add_ten(a)\n\n
       　　　return a + 10 （rubyの場合returnを省略することができます）\n\n
       　end\n\n\n
       　a = 5\n
       　puts add_ten(a)"


- kind: NameError

  difc: hard

  q_pro: |
          def set_hello
    
               hello = "Hello World"
    
          end


          puts hello
          
  q_err: |
          Main.rb:8:in `<main>': undefined local variable or method `hello' for main:Object (NameError)

  c_a: 
    - |
       8行目が変数helloのスコープ外である。
    - |
       8行目で変数helloの名前を間違えている。
    - |
       変数helloの中に型の不適切な値が代入されている。
    - |
       putsメソッドの使用方法を間違えている。

  s_a:
    - |
       set_helloメソッドから戻り値として変数helloを受け取る。
    - |
       8行目の処理をset_helloメソッドの上で行う。
    - |
       8行目を puts hello(a) にする。
    - |
       set_helloメソッドで引数として変数helloを受け取る。

  ans: 
       "ある変数を使用できる範囲の事をスコープと呼びます。またこの範囲のことをブロックと呼び、これはif文の中、\
       メソッドの中、クラスの中など色々あります。\n\n
       　if ○○            def ○○           class ○○\n
       　 （省略）            (省略)              (省略)    ・・・ブロック\n
       　end               end                 end\n\n
       　メソッドのブロックは外側と直接つながっていません。\
       そのためメソッドのブロック内で宣言された変数はブロックの外側では使用することができません。\
       問題のプログラムを見てみるとset_helloメソッド内で変数helloが宣言され、メソッドの外側で使用されています。\
       メソッドのブロックは直接外側とつながっていないためこのままでは変数helloを使用することができません。\
       ではどうすれば変数helloをsay_helloメソッドの外側で使用することができるのでしょうか。\
       この問題を解決するには「戻り値」というものを使用します。戻り値を使用すると、メソッドの外側に変数を送ることができます。\n\n
       　① 【メソッド内】return hello      (return 外側に送りたい変数)\n\n
       　→ メソッドの外側に指定した変数を送ることができるようになります。\n\n
       　② 【メソッド外】hello = set_hello\n\n
       　→ メソッドから戻り値に指定された変数を受け取ることができるようになります。\n\n
       　このようにメソッドから戻り値として変数を受け取ればメソッドのブロックの外側でもメソッド内の変数が使用できるようになります。\n\n\n\n
       　【デバッグ後の問題プログラム】\n\n
       　def set_hello\n\n
       　　　hello = ”Hello World”\n\n
       　　　return hello       (rubyの場合はreturnを省略することができます)\n\n
       　end\n\n\n
       　hello = set_hello\n
       　puts hello                   (直接 puts set_hello とすることもできます）"
       



- kind: NameError

  difc: hard

  q_pro: |
          animal = ["ウサギ","ライオン","イヌ"]
          fish = ["マグロ","サバ","アジ"]

          creatures = [aniaml[rand(0..2)],fish[rand(0..2)]]   #creatures = 生き物 

          vs = creatures[0] + "vs" + creatures[1] 

          puts vs

  q_err: |
          Main.rb:4:in `<main>': undefined local variable or method `aniaml' for main:Object (NameError)
          Did you mean?  animal

  c_a: 
    - | 
       4行目で配列animalの名前を間違えている。
    - |
       4行目で配列fishの名前を間違えている。
    - |
       6行目で配列creaturesの名前を間違えている。
    - |
       4行目の配列animalと配列fishの添え字が不適切である。

  s_a:
    - |
       4行目を creatures = [animal[rand(0..2)],fish[rand(0..2)]] にする。
    - |
       4行目を creatures = [animal[rand(0..2)],fsih[rand(0..2)]] にする。
    - |
       4行目を creatures = [animal[rand(1..3)],fish[rand(1..3)]] にする。
    - |
       4行目を creature  = [animal[rand(0..2)],fish[rand(0..2)]] にする。

  ans: 
        "このプログラムは配列の名前を間違えておりNameErrorが起きています。\
        エラーメッセージ中の「Did you mean?  animal」は「あなたが使用したいのは animal では\
        ないですか？という意味であり、「undefined local variable or method `aniaml'」は「\
        aniamlという変数または配列、メソッドを知りません」という意味です。この2つの記述から配列\
        animalを「aniaml」と間違えてしまっていることが推測できます。よって答えは配列animalが修正されている、\n
        「4行目を creatures = [animal[rand(0..2)],fish[rand(0..2)]] にする。」です。\n\n\n
        選択肢の\n「4行目を creatures = [animal[rand(0..2)],fsih[rand(0..2)]] にする。」は配列fishの名前を\
        間違えているため不正解、\n「4行目を creature  = [animal[rand(0..2)],fish[rand(0..2)]] にする。」は代入\
        されている配列は正しいですが、代入元の配列がcratureとなっており6行目でNameErrorを起こしてしまうため不正解、\n
        「4行目を creatures = [animal[rand(1..3)],fish[rand(1..3)]] にする。」はrand(1..3)とすると1から3までの\
        ランダムな整数となり、3になった場合配列の要素がないところを参照してしまうため不正解となります。添え字 = [0,1,2]"




- kind: ArgumentError

  difc: easy

  q_pro: |
          def sum(a,b)
    
               return a + b
            
          end


          puts sum(3)
          
  q_err: |
          Main.rb:1:in `sum': wrong number of arguments (given 1, expected 2) (ArgumentError)
          from Main.rb:8:in `<main>'
  c_a: 
    - |
       sumメソッドに渡す引数の数が不足している。
    - |
       sumメソッドに渡す引数の数が多すぎる。
    - |
       endが不足している。
    - |
       putsの使い方が不適切である。
  s_a:
    - |
       8行目を puts sum(3,5) にする。
    - |
       8行目を puts sum にする。
    - |
       8行目を puts sum(3,5,8) にする。
    - |
       1行目を def sum にする。

  ans: 
       "このプログラムではArgumentErrorが発生しています。Argumentとは引数のことであり、これは引数のエラーとなります。\n\n
       　エラー文の「wrong number of arguments」は「引数の数が間違っています」という意味であり、「(given 1, expected 2) 」\
       は「引数が2つ必要なのに1つしか渡されていません」という意味になります。よって引数が正しく渡されている「8行目を puts sum(3,5) にする。」\
       が正解となります。\n\n\n\n
       ーーーーーーーーーーーーー引数の説明ーーーーーーーーーーーーーー\n\n
       　引数とはメソッドに渡す値のことを指します。なぜメソッドに値を渡す必要があるのでしょうか。それはメソッドが外側の\
       プログラムと直接つながっていないためです。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                  \n
       　| def add_ten       \n
       　|      a + 10       \n 
       　| end               \n\n
       　上のような変数aに10を足すadd_tenという名前のメソッドを作成したとします。プログラムを見ると変数aはadd_tenメソッドの上で\
       作成されています。プログラムは上から下に向かって処理が行われるため、一見すると変数aはadd_tenメソッドに入って \
       a + 10 が行われるように思われます。しかし、変数aはadd_tenメソッドの中に入ることができません。これは最初にも書いた\
       通り、メソッドが外側のプログラムと直接つながっていないためです。つまりこのままでは変数aはadd_tenメソッドをすり抜けてしまい\
       add_tenメソッドから変数aを見ることができません。そこで登場するのが「引数」です。\n\n
       　引数を使用するとメソッドは外側で作成されている変数を見ることができるようになります。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                   \n
       　| def add_ten(a)    \n
       　|      a + 10       \n 
       　| end               \n\n
       　1つ目のプログラムと比較すると「def add_ten」が「def add_ten(a)」になっていることがわかります。ここで追加された「(a)」\
       の部分が「引数」です。このように\n「def メソッド名(引数)」と書くことでそのメソッドは引数として、外側で作成された変数を受け取ることが\
       できるようになります。（配列も受け取れます。）\n\n
       　しかし、「def add_ten(a)」としただけでは外側で作成されている変数を見ることはできません。実際に変数aをadd_tenメソッドに\
       渡す記述も必要です。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                   \n
       　| def add_ten(a)    \n
       　|      a + 10       \n 
       　| end               \n
       　|                   \n
       　| add_ten(a)         \n\n
       　endの下に「add_ten(a)」という記述が追加されました。この記述によってadd_tenメソッドが呼び出されます。（ただメソッドを作成\
       しただけではそのメソッドを動かすことはできず、呼び出すことで初めてメソッドを使用することができます。）そして、メソッドを\
       呼び出す際に引数を付与します。それが「(a)」の部分です。ひとつ前の説明で出てきた「def add_ten(a)」の「(a)」と
       今回の「add_ten(a)」の「(a)」は実際には全く別の変数です。次にその説明をしますが少し難しいため完璧に理解する必要はありません。\n\n
       　ひとつ前で説明した「def add_ten(a)」についている「(a)」は\
       仮の変数となります。なぜ仮の変数が必要かというと、add_tenメソッドを作成した時点ではどの変数がメソッドに入ってくるのかわからないから\
       です。このようにメソッドの作成時には仮の変数を用いて引数を受け取る準備をしておきます。この引数のことを「仮引数」と呼びます。\
       この仮引数はメソッド用に準備されるものでありメソッドの外側の変数とは別物であるため、「def add_ten(a)」の部分は必ずしも\
       変数aを使用する必要はなく、「def add_ten(b)」や「def add_ten(hikisu)」など別の変数名にしても何ら問題はありません。その代わり、
       メソッド内の処理もそれに応じて「b + 10」や「hikisu + 10」に書き換える必要があります。\n
       　次にendの下に追加された「add_ten(a)」に付与されている「(a)」の部分ですが、この変数aはadd_tenメソッドに渡す実際の変数となります。\
       つまりこの部分の変数aはadd_tenメソッドの上で宣言されている「a = 1」のaとなります。またこのような引数を「実引数」と呼びます。\n\n
       　またこれも重要な事ですが、endの下に追加された「add_ten(a)」は必ずあの場所に追加する必要があります。それはプログラムが上から下に向かって処理\
       されているためです。仮に「add_ten(a)」をadd_tenメソッドが作成されている箇所よりも上に配置したとすると、add_tenメソッドが呼ばれる際プログラムはまだadd_ten\
       メソッドの存在を知らないためエラーとなってしまいます。また変数aが作成されている箇所よりも上に配置するとadd_tenメソッドを知らないというエラーに\
       加えて変数aを知らないというエラーも起きてしまいます。\n　これらの理由からadd_tenメソッドを呼び出す記述(add_ten(a))は、add_tenメソッドと変数aが作成されている箇所よりも\
       下に追加する必要があります。\n\n\n\n
       　このようにメソッドは引数によって外側の変数を使用します。メソッドを作成する際にあらかじめ準備しておいた仮引数と\
       実際にメソッドに渡す実引数の数が一致していなければArgumentErrorとなってしまいます。\n\n
       ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー\n\n
       "


- kind: ArgumentError

  difc: easy

  q_pro: |
          def say_hello(hello)
    
               puts hello
        
          end

          say_hello("Hello World","Hello Ruby")
          
  q_err: |
          Main.rb:1:in `say_hello': wrong number of arguments (given 2, expected 1) (ArgumentError)
          from Main.rb:7:in `<main>'
  c_a: 
    - |
       say_helloメソッドに渡す引数の数が多すぎる。
    - |
       say_helloメソッドに渡す引数の数が不足している。
    - |
       say_helloメソッドが正しく呼び出されていない。
    - |
       say_helloメソッドの引数の型が不適切である。
  s_a:
    - |
       7行目を say_hello("Hello World") にする。
    - |
       7行目を say_hello("Hello Ruby","Hello World") にする。
    - |
       7行目を say_hello にする。
    - |
       1行目を def say_hello にする。
  ans: 
       "このプログラムではArgumentErrorが発生しています。Argumentとは引数のことであり、これは引数のエラーとなります。\n\n
       　エラー文の「wrong number of arguments」は「引数の数が間違っています」という意味であり、「(given 2, expected 1) 」\
       は「引数が1つ必要なのに2つも渡されています」という意味になります。よって引数が正しく渡されている「7行目を say_hello(”Hello World”) にする。」\
       が正解となります。\n\n\n\n
       ーーーーーーーーーーーーー引数の説明ーーーーーーーーーーーーーー\n\n
       　引数とはメソッドに渡す値のことを指します。なぜメソッドに値を渡す必要があるのでしょうか。それはメソッドが外側の\
       プログラムと直接つながっていないためです。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                  \n
       　| def add_ten       \n
       　|      a + 10       \n 
       　| end               \n\n
       　上のような変数aに10を足すadd_tenという名前のメソッドを作成したとします。プログラムを見ると変数aはadd_tenメソッドの上で\
       作成されています。プログラムは上から下に向かって処理が行われるため、一見すると変数aはadd_tenメソッドに入って \
       a + 10 が行われるように思われます。しかし、変数aはadd_tenメソッドの中に入ることができません。これは最初にも書いた\
       通り、メソッドが外側のプログラムと直接つながっていないためです。つまりこのままでは変数aはadd_tenメソッドをすり抜けてしまい\
       add_tenメソッドから変数aを見ることができません。そこで登場するのが「引数」です。\n\n
       　引数を使用するとメソッドは外側で作成されている変数を見ることができるようになります。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                   \n
       　| def add_ten(a)    \n
       　|      a + 10       \n 
       　| end               \n\n
       　1つ目のプログラムと比較すると「def add_ten」が「def add_ten(a)」になっていることがわかります。ここで追加された「(a)」\
       の部分が「引数」です。このように\n「def メソッド名(引数)」と書くことでそのメソッドは引数として、外側で作成された変数を受け取ることが\
       できるようになります。（配列も受け取れます。）\n\n
       　しかし、「def add_ten(a)」としただけでは外側で作成されている変数を見ることはできません。実際に変数aをadd_tenメソッドに\
       渡す記述も必要です。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                   \n
       　| def add_ten(a)    \n
       　|      a + 10       \n 
       　| end               \n
       　|                   \n
       　| add_ten(a)         \n\n
       　endの下に「add_ten(a)」という記述が追加されました。この記述によってadd_tenメソッドが呼び出されます。（ただメソッドを作成\
       しただけではそのメソッドを動かすことはできず、呼び出すことで初めてメソッドを使用することができます。）そして、メソッドを\
       呼び出す際に引数を付与します。それが「(a)」の部分です。ひとつ前の説明で出てきた「def add_ten(a)」の「(a)」と
       今回の「add_ten(a)」の「(a)」は実際には全く別の変数です。次にその説明をしますが少し難しいため完璧に理解する必要はありません。\n\n
       　ひとつ前で説明した「def add_ten(a)」についている「(a)」は\
       仮の変数となります。なぜ仮の変数が必要かというと、add_tenメソッドを作成した時点ではどの変数がメソッドに入ってくるのかわからないから\
       です。このようにメソッドの作成時には仮の変数を用いて引数を受け取る準備をしておきます。この引数のことを「仮引数」と呼びます。\
       この仮引数はメソッド用に準備されるものでありメソッドの外側の変数とは別物であるため、「def add_ten(a)」の部分は必ずしも\
       変数aを使用する必要はなく、「def add_ten(b)」や「def add_ten(hikisu)」など別の変数名にしても何ら問題はありません。その代わり、
       メソッド内の処理もそれに応じて「b + 10」や「hikisu + 10」に書き換える必要があります。\n
       　次にendの下に追加された「add_ten(a)」に付与されている「(a)」の部分ですが、この変数aはadd_tenメソッドに渡す実際の変数となります。\
       つまりこの部分の変数aはadd_tenメソッドの上で宣言されている「a = 1」のaとなります。またこのような引数を「実引数」と呼びます。\n\n
       　またこれも重要な事ですが、endの下に追加された「add_ten(a)」は必ずあの場所に追加する必要があります。それはプログラムが上から下に向かって処理\
       されているためです。仮に「add_ten(a)」をadd_tenメソッドが作成されている箇所よりも上に配置したとすると、add_tenメソッドが呼ばれる際プログラムはまだadd_ten\
       メソッドの存在を知らないためエラーとなってしまいます。また変数aが作成されている箇所よりも上に配置するとadd_tenメソッドを知らないというエラーに\
       加えて変数aを知らないというエラーも起きてしまいます。\n　これらの理由からadd_tenメソッドを呼び出す記述(add_ten(a))は、add_tenメソッドと変数aが作成されている箇所よりも\
       下に追加する必要があります。\n\n\n\n
        　このようにメソッドは引数によって外側の変数を使用します。メソッドを作成する際にあらかじめ準備しておいた仮引数と\
       実際にメソッドに渡す実引数の数が一致していなければArgumentErrorとなってしまいます。\n\n
       ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー\n\n
       "




- kind: ArgumentError

  difc: easy

  q_pro: |
          def put_num(number)
    
               puts number
            
          end

          put_num
          
  q_err: |
          Main.rb:1:in `put_num': wrong number of arguments (given 0, expected 1) (ArgumentError)
          from Main.rb:7:in `<main>'
  c_a: 
    - |
       put_numメソッドに渡す引数の数が不足している。
    - |
       put_numメソッドに渡す引数の数が多すぎる。
    - |
       put_numメソッドの引数の名前が不適切である。
    - |
       put_numメソッドの呼び出し方が不適切である。
  s_a:
    - |
       7行目を put_num(5) にする。
    - |
       7行目を put_num(3,5) にする。
    - |
       7行目を put_number にする。
    - |
       1行目を def put_num(number_1) にする。
  ans: 
       "このプログラムではArgumentErrorが発生しています。Argumentとは引数のことであり、これは引数のエラーとなります。\n\n
       　エラー文の「wrong number of arguments」は「引数の数が間違っています」という意味であり、「(given 0, expected 1) 」\
       は「引数が1つ必要なのに0コ渡されています」という意味になります。よって引数が正しく渡されている「7行目を put_num(5) にする。」\
       が正解となります。\n\n\n\n
       ーーーーーーーーーーーーー引数の説明ーーーーーーーーーーーーーー\n\n
       　引数とはメソッドに渡す値のことを指します。なぜメソッドに値を渡す必要があるのでしょうか。それはメソッドが外側の\
       プログラムと直接つながっていないためです。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                  \n
       　| def add_ten       \n
       　|      a + 10       \n 
       　| end               \n\n
       　上のような変数aに10を足すadd_tenという名前のメソッドを作成したとします。プログラムを見ると変数aはadd_tenメソッドの上で\
       作成されています。プログラムは上から下に向かって処理が行われるため、一見すると変数aはadd_tenメソッドに入って \
       a + 10 が行われるように思われます。しかし、変数aはadd_tenメソッドの中に入ることができません。これは最初にも書いた\
       通り、メソッドが外側のプログラムと直接つながっていないためです。つまりこのままでは変数aはadd_tenメソッドをすり抜けてしまい\
       add_tenメソッドから変数aを見ることができません。そこで登場するのが「引数」です。\n\n
       　引数を使用するとメソッドは外側で作成されている変数を見ることができるようになります。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                   \n
       　| def add_ten(a)    \n
       　|      a + 10       \n 
       　| end               \n\n
       　1つ目のプログラムと比較すると「def add_ten」が「def add_ten(a)」になっていることがわかります。ここで追加された「(a)」\
       の部分が「引数」です。このように\n「def メソッド名(引数)」と書くことでそのメソッドは引数として、外側で作成された変数を受け取ることが\
       できるようになります。（配列も受け取れます。）\n\n
       　しかし、「def add_ten(a)」としただけでは外側で作成されている変数を見ることはできません。実際に変数aをadd_tenメソッドに\
       渡す記述も必要です。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                   \n
       　| def add_ten(a)    \n
       　|      a + 10       \n 
       　| end               \n
       　|                   \n
       　| add_ten(a)         \n\n
       　endの下に「add_ten(a)」という記述が追加されました。この記述によってadd_tenメソッドが呼び出されます。（ただメソッドを作成\
       しただけではそのメソッドを動かすことはできず、呼び出すことで初めてメソッドを使用することができます。）そして、メソッドを\
       呼び出す際に引数を付与します。それが「(a)」の部分です。ひとつ前の説明で出てきた「def add_ten(a)」の「(a)」と
       今回の「add_ten(a)」の「(a)」は実際には全く別の変数です。次にその説明をしますが少し難しいため完璧に理解する必要はありません。\n\n
       　ひとつ前で説明した「def add_ten(a)」についている「(a)」は\
       仮の変数となります。なぜ仮の変数が必要かというと、add_tenメソッドを作成した時点ではどの変数がメソッドに入ってくるのかわからないから\
       です。このようにメソッドの作成時には仮の変数を用いて引数を受け取る準備をしておきます。この引数のことを「仮引数」と呼びます。\
       この仮引数はメソッド用に準備されるものでありメソッドの外側の変数とは別物であるため、「def add_ten(a)」の部分は必ずしも\
       変数aを使用する必要はなく、「def add_ten(b)」や「def add_ten(hikisu)」など別の変数名にしても何ら問題はありません。その代わり、
       メソッド内の処理もそれに応じて「b + 10」や「hikisu + 10」に書き換える必要があります。\n
       　次にendの下に追加された「add_ten(a)」に付与されている「(a)」の部分ですが、この変数aはadd_tenメソッドに渡す実際の変数となります。\
       つまりこの部分の変数aはadd_tenメソッドの上で宣言されている「a = 1」のaとなります。またこのような引数を「実引数」と呼びます。\n\n
       　またこれも重要な事ですが、endの下に追加された「add_ten(a)」は必ずあの場所に追加する必要があります。それはプログラムが上から下に向かって処理\
       されているためです。仮に「add_ten(a)」をadd_tenメソッドが作成されている箇所よりも上に配置したとすると、add_tenメソッドが呼ばれる際プログラムはまだadd_ten\
       メソッドの存在を知らないためエラーとなってしまいます。また変数aが作成されている箇所よりも上に配置するとadd_tenメソッドを知らないというエラーに\
       加えて変数aを知らないというエラーも起きてしまいます。\n　これらの理由からadd_tenメソッドを呼び出す記述(add_ten(a))は、add_tenメソッドと変数aが作成されている箇所よりも\
       下に追加する必要があります。\n\n\n\n
        　このようにメソッドは引数によって外側の変数を使用します。メソッドを作成する際にあらかじめ準備しておいた仮引数と\
       実際にメソッドに渡す実引数の数が一致していなければArgumentErrorとなってしまいます。\n\n
       ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー\n\n
       "




- kind: ArgumentError

  difc: normal

  q_pro: |
          def swap(a,b)
    
               return b, a
            
          end

          x = 5
          y = 3
          z = 7

          x,y,z = swap(x,y,z)
          
  q_err: |
          Main.rb:1:in `swap': wrong number of arguments (given 3, expected 2) (ArgumentError)
          from Main.rb:11:in `<main>'
  c_a: 
    - |
       swapメソッドに渡す引数の数が多すぎる。
    - |
       swapメソッドに渡す引数の数が不足している。
    - |
       swapメソッドに渡す引数の名前を間違えている。
    - |
       swapメソッドの戻り値の数が不足している。
  s_a:
    - |
       11行目を x,y = swap(x,y) にする。
    - |
       11行目を x,y = swap(x,y,z) にする。
    - |
       11行目を x,y = swap(x) にする。
    - |
       11行目を x,y,z = swap(x) にする。
  ans: 
       "このプログラムではArgumentErrorが発生しています。Argumentとは引数のことであり、これは引数のエラーとなります。\n\n
       　エラー文の「wrong number of arguments」は「引数の数が間違っています」という意味であり、「(given 3, expected 2) 」\
       は「引数が2つ必要なのに3つも渡されています」という意味になります。よって引数が正しく渡されている「11行目を x,y = swap(x,y) にする。」\
       が正解となります。\n\n　余談ですが、一般的には戻り値は1つしか返せませんがRubyのように複数の戻り値を返せるプログラミング言語も存在しています。\n\n\n\n
       ーーーーーーーーーーーーー引数の説明ーーーーーーーーーーーーーー\n\n
       　引数とはメソッドに渡す値のことを指します。なぜメソッドに値を渡す必要があるのでしょうか。それはメソッドが外側の\
       プログラムと直接つながっていないためです。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                  \n
       　| def add_ten       \n
       　|      a + 10       \n 
       　| end               \n\n
       　上のような変数aに10を足すadd_tenという名前のメソッドを作成したとします。プログラムを見ると変数aはadd_tenメソッドの上で\
       作成されています。プログラムは上から下に向かって処理が行われるため、一見すると変数aはadd_tenメソッドに入って \
       a + 10 が行われるように思われます。しかし、変数aはadd_tenメソッドの中に入ることができません。これは最初にも書いた\
       通り、メソッドが外側のプログラムと直接つながっていないためです。つまりこのままでは変数aはadd_tenメソッドをすり抜けてしまい\
       add_tenメソッドから変数aを見ることができません。そこで登場するのが「引数」です。\n\n
       　引数を使用するとメソッドは外側で作成されている変数を見ることができるようになります。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                   \n
       　| def add_ten(a)    \n
       　|      a + 10       \n 
       　| end               \n\n
       　1つ目のプログラムと比較すると「def add_ten」が「def add_ten(a)」になっていることがわかります。ここで追加された「(a)」\
       の部分が「引数」です。このように\n「def メソッド名(引数)」と書くことでそのメソッドは引数として、外側で作成された変数を受け取ることが\
       できるようになります。（配列も受け取れます。）\n\n
       　しかし、「def add_ten(a)」としただけでは外側で作成されている変数を見ることはできません。実際に変数aをadd_tenメソッドに\
       渡す記述も必要です。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                   \n
       　| def add_ten(a)    \n
       　|      a + 10       \n 
       　| end               \n
       　|                   \n
       　| add_ten(a)         \n\n
       　endの下に「add_ten(a)」という記述が追加されました。この記述によってadd_tenメソッドが呼び出されます。（ただメソッドを作成\
       しただけではそのメソッドを動かすことはできず、呼び出すことで初めてメソッドを使用することができます。）そして、メソッドを\
       呼び出す際に引数を付与します。それが「(a)」の部分です。ひとつ前の説明で出てきた「def add_ten(a)」の「(a)」と
       今回の「add_ten(a)」の「(a)」は実際には全く別の変数です。次にその説明をしますが少し難しいため完璧に理解する必要はありません。\n\n
       　ひとつ前で説明した「def add_ten(a)」についている「(a)」は\
       仮の変数となります。なぜ仮の変数が必要かというと、add_tenメソッドを作成した時点ではどの変数がメソッドに入ってくるのかわからないから\
       です。このようにメソッドの作成時には仮の変数を用いて引数を受け取る準備をしておきます。この引数のことを「仮引数」と呼びます。\
       この仮引数はメソッド用に準備されるものでありメソッドの外側の変数とは別物であるため、「def add_ten(a)」の部分は必ずしも\
       変数aを使用する必要はなく、「def add_ten(b)」や「def add_ten(hikisu)」など別の変数名にしても何ら問題はありません。その代わり、
       メソッド内の処理もそれに応じて「b + 10」や「hikisu + 10」に書き換える必要があります。\n
       　次にendの下に追加された「add_ten(a)」に付与されている「(a)」の部分ですが、この変数aはadd_tenメソッドに渡す実際の変数となります。\
       つまりこの部分の変数aはadd_tenメソッドの上で宣言されている「a = 1」のaとなります。またこのような引数を「実引数」と呼びます。\n\n
       　またこれも重要な事ですが、endの下に追加された「add_ten(a)」は必ずあの場所に追加する必要があります。それはプログラムが上から下に向かって処理\
       されているためです。仮に「add_ten(a)」をadd_tenメソッドが作成されている箇所よりも上に配置したとすると、add_tenメソッドが呼ばれる際プログラムはまだadd_ten\
       メソッドの存在を知らないためエラーとなってしまいます。また変数aが作成されている箇所よりも上に配置するとadd_tenメソッドを知らないというエラーに\
       加えて変数aを知らないというエラーも起きてしまいます。\n　これらの理由からadd_tenメソッドを呼び出す記述(add_ten(a))は、add_tenメソッドと変数aが作成されている箇所よりも\
       下に追加する必要があります。\n\n\n\n
        　このようにメソッドは引数によって外側の変数を使用します。メソッドを作成する際にあらかじめ準備しておいた仮引数と\
       実際にメソッドに渡す実引数の数が一致していなければArgumentErrorとなってしまいます。\n\n
       ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー\n\n
       "



- kind: ArgumentError

  difc: normal

  q_pro: |
          def set_hello(a)
    
               hello = ""
            
               if a == 0
                  hello = "Hello World"
               else
                  hello = "Hello Ruby"
               end
            
               return hello
            
          end

          x = rand(0..1)

          puts set_hello(x, 0)
          
  q_err: |
          Main.rb:1:in `set_hello': wrong number of arguments (given 2, expected 1) (ArgumentError)
          from Main.rb:17:in `<main>'
  c_a: 
    - |
       set_helloメソッドに渡す引数の数が多すぎる。
    - |
       set_helloメソッドに渡す引数の数が不足している。
    - |
       set_helloメソッドに渡す引数の名前を間違えている。
    - |
       set_helloメソッド内で存在しない変数aが使用されている。
  s_a:
    - |
       17行目を puts set_hello(x) にする。
    - |
       17行目を puts set_hello(a) にする。
    - |
       17行目を puts set_hello にする。
    - |
       5行目を if x == 0 にする。
  ans: 
       "このプログラムではArgumentErrorが発生しています。Argumentとは引数のことであり、これは引数のエラーとなります。\n\n
       　エラー文の「wrong number of arguments」は「引数の数が間違っています」という意味であり、「(given 2, expected 1) 」\
       は「引数が1つ必要なのに2つも渡されています」という意味になります。よって引数が正しく渡されている「17行目を puts set_hello(x) にする。」\
       が正解となります。\n
       　選択肢の\n
       「17行目を puts set_hello(a) にする。」について、変数aはset_helloメソッドの仮引数でありメソッドの外側では無効\
       であるためNameErrorとなり不正解。\n
       「5行目を if x == 0 にする。」について、変数xはset_helloメソッドの外側で宣言されている変数でありメソッド内では\
       無効であるためNameErrorとなり不正解である。\n\n\n\n
       ーーーーーーーーーーーーー引数の説明ーーーーーーーーーーーーーー\n\n
       　引数とはメソッドに渡す値のことを指します。なぜメソッドに値を渡す必要があるのでしょうか。それはメソッドが外側の\
       プログラムと直接つながっていないためです。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                  \n
       　| def add_ten       \n
       　|      a + 10       \n 
       　| end               \n\n
       　上のような変数aに10を足すadd_tenという名前のメソッドを作成したとします。プログラムを見ると変数aはadd_tenメソッドの上で\
       作成されています。プログラムは上から下に向かって処理が行われるため、一見すると変数aはadd_tenメソッドに入って \
       a + 10 が行われるように思われます。しかし、変数aはadd_tenメソッドの中に入ることができません。これは最初にも書いた\
       通り、メソッドが外側のプログラムと直接つながっていないためです。つまりこのままでは変数aはadd_tenメソッドをすり抜けてしまい\
       add_tenメソッドから変数aを見ることができません。そこで登場するのが「引数」です。\n\n
       　引数を使用するとメソッドは外側で作成されている変数を見ることができるようになります。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                   \n
       　| def add_ten(a)    \n
       　|      a + 10       \n 
       　| end               \n\n
       　1つ目のプログラムと比較すると「def add_ten」が「def add_ten(a)」になっていることがわかります。ここで追加された「(a)」\
       の部分が「引数」です。このように\n「def メソッド名(引数)」と書くことでそのメソッドは引数として、外側で作成された変数を受け取ることが\
       できるようになります。（配列も受け取れます。）\n\n
       　しかし、「def add_ten(a)」としただけでは外側で作成されている変数を見ることはできません。実際に変数aをadd_tenメソッドに\
       渡す記述も必要です。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                   \n
       　| def add_ten(a)    \n
       　|      a + 10       \n 
       　| end               \n
       　|                   \n
       　| add_ten(a)         \n\n
       　endの下に「add_ten(a)」という記述が追加されました。この記述によってadd_tenメソッドが呼び出されます。（ただメソッドを作成\
       しただけではそのメソッドを動かすことはできず、呼び出すことで初めてメソッドを使用することができます。）そして、メソッドを\
       呼び出す際に引数を付与します。それが「(a)」の部分です。ひとつ前の説明で出てきた「def add_ten(a)」の「(a)」と
       今回の「add_ten(a)」の「(a)」は実際には全く別の変数です。次にその説明をしますが少し難しいため完璧に理解する必要はありません。\n\n
       　ひとつ前で説明した「def add_ten(a)」についている「(a)」は\
       仮の変数となります。なぜ仮の変数が必要かというと、add_tenメソッドを作成した時点ではどの変数がメソッドに入ってくるのかわからないから\
       です。このようにメソッドの作成時には仮の変数を用いて引数を受け取る準備をしておきます。この引数のことを「仮引数」と呼びます。\
       この仮引数はメソッド用に準備されるものでありメソッドの外側の変数とは別物であるため、「def add_ten(a)」の部分は必ずしも\
       変数aを使用する必要はなく、「def add_ten(b)」や「def add_ten(hikisu)」など別の変数名にしても何ら問題はありません。その代わり、
       メソッド内の処理もそれに応じて「b + 10」や「hikisu + 10」に書き換える必要があります。\n
       　次にendの下に追加された「add_ten(a)」に付与されている「(a)」の部分ですが、この変数aはadd_tenメソッドに渡す実際の変数となります。\
       つまりこの部分の変数aはadd_tenメソッドの上で宣言されている「a = 1」のaとなります。またこのような引数を「実引数」と呼びます。\n\n
       　またこれも重要な事ですが、endの下に追加された「add_ten(a)」は必ずあの場所に追加する必要があります。それはプログラムが上から下に向かって処理\
       されているためです。仮に「add_ten(a)」をadd_tenメソッドが作成されている箇所よりも上に配置したとすると、add_tenメソッドが呼ばれる際プログラムはまだadd_ten\
       メソッドの存在を知らないためエラーとなってしまいます。また変数aが作成されている箇所よりも上に配置するとadd_tenメソッドを知らないというエラーに\
       加えて変数aを知らないというエラーも起きてしまいます。\n　これらの理由からadd_tenメソッドを呼び出す記述(add_ten(a))は、add_tenメソッドと変数aが作成されている箇所よりも\
       下に追加する必要があります。\n\n\n\n
        　このようにメソッドは引数によって外側の変数を使用します。メソッドを作成する際にあらかじめ準備しておいた仮引数と\
       実際にメソッドに渡す実引数の数が一致していなければArgumentErrorとなってしまいます。\n\n
       ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー\n\n
       "




- kind: ArgumentError

  difc: normal

  q_pro: |
          def set_hello(a)
    
               hello = ""
            
               if a == 0
                  hello = "Hello World"
               else
                  hello = "Hello Ruby"
               end
            
               return hello
            
          end

          x = rand(0..1)

          puts set_hello(x, 0)
          
  q_err: |
          Main.rb:1:in `set_hello': wrong number of arguments (given 2, expected 1) (ArgumentError)
          from Main.rb:17:in `<main>'
  c_a: 
    - |
       set_helloメソッドに渡す引数の数が多すぎる。
    - |
       set_helloメソッドに渡す引数の数が不足している。
    - |
       set_helloメソッドに渡す引数の名前を間違えている。
    - |
       set_helloメソッド内で存在しない変数aが使用されている。
  s_a:
    - |
       17行目を puts set_hello(x) にする。
    - |
       17行目を puts set_hello(a) にする。
    - |
       17行目を puts set_hello にする。
    - |
       5行目を if x == 0 にする。
  ans: 
       "このプログラムではArgumentErrorが発生しています。Argumentとは引数のことであり、これは引数のエラーとなります。\n\n
       　エラー文の「wrong number of arguments」は「引数の数が間違っています」という意味であり、「(given 2, expected 1) 」\
       は「引数が1つ必要なのに2つも渡されています」という意味になります。よって引数が正しく渡されている「17行目を puts set_hello(x) にする。」\
       が正解となります。\n
       　選択肢の\n
       「17行目を puts set_hello(a) にする。」について、変数aはset_helloメソッドの仮引数でありメソッドの外側では無効\
       であるためNameErrorとなり不正解。\n
       「5行目を if x == 0 にする。」について、変数xはset_helloメソッドの外側で宣言されている変数でありメソッド内では\
       無効であるためNameErrorとなり不正解である。\n\n\n\n
       ーーーーーーーーーーーーー引数の説明ーーーーーーーーーーーーーー\n\n
       　引数とはメソッドに渡す値のことを指します。なぜメソッドに値を渡す必要があるのでしょうか。それはメソッドが外側の\
       プログラムと直接つながっていないためです。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                  \n
       　| def add_ten       \n
       　|      a + 10       \n 
       　| end               \n\n
       　上のような変数aに10を足すadd_tenという名前のメソッドを作成したとします。プログラムを見ると変数aはadd_tenメソッドの上で\
       作成されています。プログラムは上から下に向かって処理が行われるため、一見すると変数aはadd_tenメソッドに入って \
       a + 10 が行われるように思われます。しかし、変数aはadd_tenメソッドの中に入ることができません。これは最初にも書いた\
       通り、メソッドが外側のプログラムと直接つながっていないためです。つまりこのままでは変数aはadd_tenメソッドをすり抜けてしまい\
       add_tenメソッドから変数aを見ることができません。そこで登場するのが「引数」です。\n\n
       　引数を使用するとメソッドは外側で作成されている変数を見ることができるようになります。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                   \n
       　| def add_ten(a)    \n
       　|      a + 10       \n 
       　| end               \n\n
       　1つ目のプログラムと比較すると「def add_ten」が「def add_ten(a)」になっていることがわかります。ここで追加された「(a)」\
       の部分が「引数」です。このように\n「def メソッド名(引数)」と書くことでそのメソッドは引数として、外側で作成された変数を受け取ることが\
       できるようになります。（配列も受け取れます。）\n\n
       　しかし、「def add_ten(a)」としただけでは外側で作成されている変数を見ることはできません。実際に変数aをadd_tenメソッドに\
       渡す記述も必要です。次のプログラムを見てください。\n\n
       　| a = 1             \n
       　|                   \n
       　| def add_ten(a)    \n
       　|      a + 10       \n 
       　| end               \n
       　|                   \n
       　| add_ten(a)         \n\n
       　endの下に「add_ten(a)」という記述が追加されました。この記述によってadd_tenメソッドが呼び出されます。（ただメソッドを作成\
       しただけではそのメソッドを動かすことはできず、呼び出すことで初めてメソッドを使用することができます。）そして、メソッドを\
       呼び出す際に引数を付与します。それが「(a)」の部分です。ひとつ前の説明で出てきた「def add_ten(a)」の「(a)」と
       今回の「add_ten(a)」の「(a)」は実際には全く別の変数です。次にその説明をしますが少し難しいため完璧に理解する必要はありません。\n\n
       　ひとつ前で説明した「def add_ten(a)」についている「(a)」は\
       仮の変数となります。なぜ仮の変数が必要かというと、add_tenメソッドを作成した時点ではどの変数がメソッドに入ってくるのかわからないから\
       です。このようにメソッドの作成時には仮の変数を用いて引数を受け取る準備をしておきます。この引数のことを「仮引数」と呼びます。\
       この仮引数はメソッド用に準備されるものでありメソッドの外側の変数とは別物であるため、「def add_ten(a)」の部分は必ずしも\
       変数aを使用する必要はなく、「def add_ten(b)」や「def add_ten(hikisu)」など別の変数名にしても何ら問題はありません。その代わり、
       メソッド内の処理もそれに応じて「b + 10」や「hikisu + 10」に書き換える必要があります。\n
       　次にendの下に追加された「add_ten(a)」に付与されている「(a)」の部分ですが、この変数aはadd_tenメソッドに渡す実際の変数となります。\
       つまりこの部分の変数aはadd_tenメソッドの上で宣言されている「a = 1」のaとなります。またこのような引数を「実引数」と呼びます。\n\n
       　またこれも重要な事ですが、endの下に追加された「add_ten(a)」は必ずあの場所に追加する必要があります。それはプログラムが上から下に向かって処理\
       されているためです。仮に「add_ten(a)」をadd_tenメソッドが作成されている箇所よりも上に配置したとすると、add_tenメソッドが呼ばれる際プログラムはまだadd_ten\
       メソッドの存在を知らないためエラーとなってしまいます。また変数aが作成されている箇所よりも上に配置するとadd_tenメソッドを知らないというエラーに\
       加えて変数aを知らないというエラーも起きてしまいます。\n　これらの理由からadd_tenメソッドを呼び出す記述(add_ten(a))は、add_tenメソッドと変数aが作成されている箇所よりも\
       下に追加する必要があります。\n\n\n\n
        　このようにメソッドは引数によって外側の変数を使用します。メソッドを作成する際にあらかじめ準備しておいた仮引数と\
       実際にメソッドに渡す実引数の数が一致していなければArgumentErrorとなってしまいます。\n\n
       ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー\n\n
       "





- kind: ArgumentError

  difc: hard

  q_pro: |
          animal = ["ライオン","ネコ"]

          animal.delete_at()
          
  q_err: |
          Main.rb:3:in `delete_at': wrong number of arguments (given 0, expected 1) (ArgumentError)
          from Main.rb:3:in `<main>'

  c_a: 
    - |
       delete_atメソッドに渡す引数の数が不足している。
    - |
       delete_atメソッドを使用する位置が不適切である。
    - |
       delete_atメソッドを作成していない。
    - |
       delete_atメソッドは配列animalには使用できない。
  s_a:
    - |
       3行目を animal.delete_at(0) にする。
    - |
       3行目を animal.delete_at(2) にする。
    - |
       3行目を delete_at(animal) にする。
    - |
       3行目を animal.delete_at(0,1) にする。
  ans: 
       "このプログラムではArgumentErrorが発生しています。Argumentとは引数のことであり、これは引数のエラーとなります。\n\n
       　エラー文の「wrong number of arguments」は「引数の数が間違っています」という意味であり、「(given 0, expected 1) 」\
       は「引数が1つ必要なのに0コ渡されています」という意味になります。\n\n
       　delete_atメソッドとはRubyで用意されている配列の要素を削除するメソッドです。次に使い方を説明します。\n\n
       　      配列名.delete_at(削除したい要素の添え字）\n\n
       　上のように書くことで特定の要素を削除できるようになります。このdelete_atメソッドは引数を1つだけ取ります。\
       よって選択肢の「3行目を animal.delete_at(0,1) にする。」は引数が多すぎるため不正解です。また「3行目を animal.delete_at(2) にする。」\
       は引数の数は合っていますが配列animalには添え字2に対応する要素がないため不正解です。(添え字=[0,1])\n\n
       　このように、自作したメソッドだけでなく元々プログラミング言語ごとに用意されているメソッドについてもArgumentErrorが発生する可能性があります。\
       用意されているメソッドを使用する際はリファレンスなどでメソッドの使用方法をよく確認しておくようにしましょう。"




- kind: ArgumentError

  difc: hard

  q_pro: |
          #プログラム説明: ふたつのメソッドを組み合わせて出力する言葉を決める

          def set_hello(flg)
    
               if flg == true
                  return "Hello World"
               else
                  return "Hello Ruby"
               end
            
          end


          def set_flg(a,b)
            
               if a == 0 && b == 0
                  return true
               else
                  return false
               end
            
          end



          puts set_hello(set_flg(rand(0..1)))
          
  q_err: |
          Main.rb:14:in `set_flg': wrong number of arguments (given 1, expected 2) (ArgumentError)
          from Main.rb:26:in `<main>'

  c_a: 
    - |
       set_flgメソッドに渡す引数の数が不足している。
    - |
       set_helloメソッドに渡す引数の数が不足している。
    - |
       set_helloメソッドに渡す引数の数が多すぎる。
    - |
       set_helloメソッドのif文処理が不適切である。
  s_a:
    - |
       26行目を puts set_hello(set_flg(rand(0..1),rand(0..1))) にする。
    - |
       26行目を puts set_hello(set_flg(rand(0..1)),rand(0..1)) にする。
    - |
       26行目を puts set_hello(rand(0..1),rand(0..1)) にする。
    - |
       26行目を puts set_hello(set_flg(a,b)) にする。

  ans: 
       "このプログラムではArgumentErrorが発生しています。Argumentとは引数のことであり、これは引数のエラーとなります。\n\n
       　エラー文の「wrong number of arguments」は「引数の数が間違っています」という意味であり、「(given 1, expected 2) 」\
       は「引数が2つ必要なのに1つしか渡されていません」という意味になります。\n\n
       　プログラム中にメソッドがふたつありますが、エラーメッセージを見ると「in `set_flg'」とあるためset_flgメソッド\
       の方に引数のミスがあることがわかります。set_flgメソッドが作成されている箇所を見ると「def set_flg(a,b)」となっており、\
       引数を2つ必要としていますが、set_flgメソッドの呼び出し箇所を見てみると「set_flg(rand(0..1))」と引数が1つしか渡されていません。\
       よってset_flgメソッドに2つ引数が渡されている「26行目を puts set_hello(set_flg(rand(0..1),rand(0..1))) にする」が正解になります。\n\n
       　選択肢の「26行目を puts set_hello(set_flg(a,b)) にする。」は引数の数は正しいですが、変数a,bはset_flgメソッド内でのみ有効な\
       変数であるため実引数として使用することはできず不正解です。"





- kind: ArgumentError

  difc: hard

  q_pro: |
          #プログラム説明: 2つのうち選択された方の問題を出題する

          class Question
            
              def initialize
                  @ques_1 = "3 + 5 = ?"
                  @ques_2 = "5 + 7 = ?"
               end
            
            def ask_q(a)

                  if a == 1

                        puts @ques_1
                        @ans = 8
                        return true

                  elsif a == 2

                        puts @ques_2
                        @ans = 12
                        return true

                  else

                        print "半角で1か2を入力してください:"
                        return false

                  end

            end
            
            def check(resp)

                  if @ans == resp
                     puts "正解！"
                  else
                     puts "不正解"
                  end
            end
            
          end

          #-------------ここからメイン--------------

          ques = Question.new

          print "問題を選択してください（1か2を入力）:"

          flg = false

          while flg == false
               flg = ques.ask_q(gets.to_i, rand(0..3))
          end

          print "回答を入力してください:"

          ques.check(gets.to_i)
          
  q_err: |
          Main.rb:10:in `ask_q': wrong number of arguments (given 2, expected 1) (ArgumentError)
          from Main.rb:53:in `<main>'

  c_a: 
    - |
       ask_qメソッドに渡す引数の数が多すぎる。
    - |
       ask_qとcheckメソッドにインスタンス変数が渡されていない。
    - |
       ask_qメソッドの引数として0もしくは3が送られる可能性がある。
    - |
       initializeメソッドで宣言されていないインスタンス変数が使用されている。
  s_a:
    - |
       53行目を flg = ques.ask_q(gets.to_i) にする。
    - |
       53行目を flg = ques.ask_q(gets.to_i, rand(1..2)) にする。
    - |
       53行目を flg = ques.ask_q(3) にする。
    - |
       53行目を flg = ques.ask_q(abs(gets.to_i) + 3) にする。

  ans: 
       "このプログラムではArgumentErrorが発生しています。Argumentとは引数のことであり、これは引数のエラーとなります。\n\n
       　エラー文の「wrong number of arguments」は「引数の数が間違っています」という意味であり、「(given 2, expected 1) 」\
       は「引数が1つ必要なのに2つも渡されています」という意味になります。\n\n
       　プログラムのQuestionクラス中にメソッドがふたつありますが、エラーメッセージを見ると「in `ask_q'」とあるためask_qメソッド\
       の方に引数のミスがあることがわかります。ask_qメソッドが作成されている箇所を見ると「def ask_q(a)」となっており、\
       引数を1つ必要としていますが、ask_qメソッドの呼び出し箇所を見てみると「ques.ask_q(gets.to_i, rand(0..3))」と引数が2つも渡されています。\
       よってask_qメソッドに引数が1つだけ渡されている「53行目を flg = ques.ask_q(gets.to_i) にする。」が正解になります。\n\n
       選択肢の\n
       「10行目を def ask_q(3) にする。」は引数の数は正しくエラーは出ませんが、ask_qメソッドに3が送られ続けることになります。\
       ask_qメソッドの処理を見ると1と2以外の場合はfalseを返します。そのため3が送られ続けると52行目のwhile文から抜け出せず無限ループとなってしまうため不正解です。\n
       「53行目を flg = ques.ask_q(abs(gets.to_i) + 3) にする。」も引数の数は正しくエラーは出ませんが、ask_qメソッドに必ず3以上の\
       数が送られることになり、処理が進まないバグとなってしまうため不正解です。(.absは絶対値を返すメソッドであるため負の数を入力しても\
       必ず3以上となります。）\n\n
       また原因の選択肢にあった\n
       「ask_qとcheckメソッドにインスタンス変数が渡されていない。」について、インスタンス変数はそのクラスの中ならばどこからでも使用\
       できるため引数にする必要はありません。\n
       「initializeメソッドで宣言されていないインスタンス変数が使用されている。」について、インスタンス変数はinitializeメソッド以外\
       でも宣言することができます。"





#- kind: 
#
#  difc:
#
#  q_pro: |
#          
#  q_err: |
#          
#  c_a: 
#    - |
#       
#    - |
#       
#    - |
#       
#    - |
#       
#  s_a:
#    - |
#       
#    - |
#       
#    - |
#       
#    - |
#       
#  ans: 
#       "" 